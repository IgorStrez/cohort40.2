## 01. Лямбда-выражения и функциональные интерфейсы
* Оказывается, что в ОЗУ сохраняются не только переменные, но и методы.
* Это значит (то что методы тоже лежат в памяти), что на них можно делать ссылки.
* Чтобы получить метод как значение, которое можно записать в переменную, нужно указать имя класса, а потом
  оператор разрешения областей видимости `::` (scope resolution operator).
* Это значение будет называться ссылкой на метод (method reference).
* Это значение теперь можно записать в переменную.
* Тип переменной, в которую можно записать эту ссылку будет функциональным интерфейсом
* Функциональный интерфейс - это такой интерфейс, у которого есть всего один не реализованный метод, и он (интерфейс)
  аннотирован как `@FunctionalInterface`
* Для методов с разными конфигурациями возвращаемых значений и параметров существуют разные функциональные интерфейсы.
* Например, для методов которые ничего не принимают и ничего не возвращают используется Runnable

* Лямбда-выражения (ЛВ) - они же анонимные функции - это такие методы, которые определены внутри выполняемых блоков кода.
* ЛВ не могут существовать сами по себе, они обязательно должны быть записаны в переменную типа функционального интерфейса.
* ЛВ выполняются не при определении, а при вызове из переменной.
* Так как ЛВ можно передавать как переменные в другие методы, это, по сути, является способом передавать недостающие
  куски кода в другие методы.
* Синтаксис:
```
(параметры) -> {выполняемый код}
```
* Обратите внимание, что "->" это два символа, "тире" и "знак больше"

* Основные функциональные интерфейсы в Java:
    * Runnable - ЛВ которые не возвращают и не принимают ничего
    * Supplier - ЛВ которые ничего не принимают, но что-то возвращают
    * Consumer - ЛВ которые что-то принимают, но ничего не возвращают
    * Function - ЛВ которые принимают один параметр, и что-то возвращают
    * Predicate - ЛВ которые принимают один параметр и возвращают boolean
    * Comparator - ЛВ которое принимает два параметра и сравнивает их. Возвращает 1, 0 или -1 в зависимости
      от результата сравнения. 1 если первый объект больше второго, 0 если они равны, -1 если второй больше первого

## 02. Stream API
* API - Application programming interface - такой набор классов, который позволяет вам взаимодействовать с чем-то.
* StreamAPI - Библиотека в джаве, которая позволяет очень быстро и удобно обрабатывать данные.
* Эта библиотека может заменить десятки строк на одну инструкцию.
* Но при этом эта инструкция все равно будет занимать несколько строк.
* Основным классом является Stream - поток объектов.
* В этом потоке объектов, над ними можно делать различные манипуляции:

* Создание:
    * .stream() у любой коллекции - создает поток и кладет в него все элементы коллекции.
    * Stream.of() - Создает поток из всех элементов, которые будут сюда переданы.
    * Arrays.stream() - Создает поток и добавляет в него все элементы переданного массива.
* Обработка данных (промежуточные операции, intermidiate operations):
    * filter - принимает предикат, удаляет все элементы из потока, которые не подходят (предикат для них вернул false).
    * limit - принимает число и ограничивает количество элементов потока до этого числа (обрезает).
    * map - принимает функцию, которая преобразовывает один объект в другой. Таким образом можно поменять обобщенный тип потока.
    * distinct - удаляет все дубликаты.
    * sorted - сортирует поток по натуральному порядку, либо по предоставленному компаратору.
    * skip - принимает число и удаляет такое количетсво элементов с начала.
    * dropWhile - принимает предикат, и удаляет с начала все элементы, пока для них предикат возвращает false
    * peek - принимает потребителя (Consumer) и выполняет его на каждом элементе.
    * flatMap - "уравнивает" поток из коллекций, так, чтобы после этого в потоке были только элементы самих коллекций
* Сбор данных (терминальные операции, terminal operations):
    * count - возвращет количество элементов в потоке, на котором он был вызван
    * forEach - делает тоже самое что и peek, только при этом завершает работу потока (возвращает void).
    * reduce - уменьшает весь поток до одного элемента, правило уменьшения задается переданной функцией
    * anyMatch - возвращает true, если хотябы один элемент совпадает с переданным предикатом
    * allMatch - возвращает true, если все элементы дают true с переданным предикатом
    * noneMatch - возвращает true, если все элементы дают false с переданным предикатом
    * max/min - возвращает максимальное/минимальное значение (по переданному компаратору)
    * collect - принимает коллектор, возвращает поток как коллекцию
    * toList - возвращает поток как обычный список (с 16 версии джавы)


